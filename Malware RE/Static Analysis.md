Owner - jason

Running `file` on the machine will attempt to show you the file type based on the information within the binary.
- It will also show if the file is **stripped**, meaning it has had it's symbol table and debugging information removed
	- this is often done to reduce the size of the binary and to make reverse-engineering harder
	- you can often use *gdb* or `objdump` to analyze stripped binaries
Can use [bintropy](https://github.com/packing-box/bintropy) to determine if bin is packed, can generate plots as well

#### FLOSS
- good string checker
`floss -n 7 <filename>`

#### Capa
- check for capabilities within the binary
`capa.exe <filename> -vv`

#### PE Studio
- one stop shop for tons of info. headers, sections, imports, strings, etc

# Advanced

## Cutter
this is my preferred disassembler/debugger
Cutter is a reverse engineering platform that integrated the radare2 RE framework, providing a user-friendly interface for disassembling and analyzing binaries.
- **Disassembly**: The main feature of Cutter, you can view the assembly code of a binary. 
- **Graph View**: This will help you visualize the flow of execution within a function.

**Trick to finding main function**
- Go to the last place where a function returns something into the *eax* register
- in the C runtime, the last thing that is called will return from the main to the C runtime
- basically look in the C runtime boilerplate code and find the last time something is in *eax*
	- look backwards to see where that value that was pushed into eax is found
	- look for the function before that

## Shellcode
- To analyze shellcode, it must be in a format we we can carve from it.
- Example here the unneeded data is stripped to just the hex characters.
Save it to a `.bin` format.
![[images/Pasted image 20250106223849.png]]

### scdbg
SCDbg is a shellcode debugger that allows you to analyze and debug shellcode. It accepts raw binary format.
- `scdbg -f <filename> -s -1`
	- this will instruct scdbg to read the entire contents of the specified file as shellcode and execute it.
	- it will spit out important instructions and info
	- ![[Pasted image 20250106230522.png]]
## Carving Shellcode from Memory

Shellcode is most common in binary format, embedded into a binary or injected into a process.
Indicators of injection
- CreateRemoteThread
- WriteProcessMemory
- VirtualProtect
- OpenProcess
- GetCurrentThreadId
We want to interrupt *WriteProcessMemory* to scrape the shellcode that is about to be injected

WriteProcessMemory takes 5 arguments
![[Pasted image 20250110195158.png]]
**hProcess:** Process to be injected
**lpBaseAddress**: Address to inject at
**lpBuffer:** The shellcode to be injected

You can use Cutter to find the location of the API call then use [[x64dbg]] to set a breakpoint and dump the memory.
![[Pasted image 20250110195415.png]]

In this example, the third argument from the WinAPI `WriteProcessMemory` is stored in r8. If we set a breakpoint and arrive at the WinAPI call location, we can then follow the memory dump of the r8 value by right clicking -> Follow in Dump -> r8: XXXXXX
![[Pasted image 20250110195540.png]]

Bottom left corner in x64dbg will navigate to the hexdump location. You can highlight all of the hex code, right click -> Binary -> Save To a File (save as output.bin)

![[Pasted image 20250110195748.png]]

And now we can open the bin in a hex editor. At this point we can use **scdbg** to analyze the shellcode.
![[Pasted image 20250110195912.png]]